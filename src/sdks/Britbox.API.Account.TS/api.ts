/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * BRITBOX ACCOUNT API - 1.0
 * BRITBOX ACCOUNT API
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://staging-api.britbox.takeoffmedia.com/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsAuthorizationAuthenticateCustomerRequest
 */
export interface BritboxAPIAccountModelsAuthorizationAuthenticateCustomerRequest {
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsAuthorizationAuthenticateCustomerRequest
     */
    contactUserName: string;
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsAuthorizationAuthenticateCustomerRequest
     */
    contactPassword: string;
    /**
     *
     * @type {BritboxDataEvergentModelsDeviceDetails}
     * @memberof BritboxAPIAccountModelsAuthorizationAuthenticateCustomerRequest
     */
    deviceDetails: BritboxDataEvergentModelsDeviceDetails;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenRequest
 */
export interface BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenRequest {
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenRequest
     */
    authCode: string;
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenRequest
     */
    deviceName: string;
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenRequest
     */
    deviceType: string;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenResponse
 */
export interface BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenResponse {
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenResponse
     */
    authCode?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenResponse
     */
    expiresIn?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenResponse
     */
    accessToken?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenResponse
     */
    refreshToken?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenResponse
     */
    responseCode?: string;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsAuthorizationRefreshTokenRequest
 */
export interface BritboxAPIAccountModelsAuthorizationRefreshTokenRequest {
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsAuthorizationRefreshTokenRequest
     */
    refreshToken: string;
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsAuthorizationRefreshTokenRequest
     */
    deviceName: string;
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsAuthorizationRefreshTokenRequest
     */
    deviceType: string;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsAuthorizationRefreshTokenResponse
 */
export interface BritboxAPIAccountModelsAuthorizationRefreshTokenResponse {
    /**
     *
     * @type {BritboxDataEvergentModelsRefreshTokenResponseMessageBaseResponse}
     * @memberof BritboxAPIAccountModelsAuthorizationRefreshTokenResponse
     */
    response?: BritboxDataEvergentModelsRefreshTokenResponseMessageBaseResponse;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsCustomerAddSubscriptionResponse
 */
export interface BritboxAPIAccountModelsCustomerAddSubscriptionResponse {
    /**
     *
     * @type {BritboxDataEvergentModelsAddSubscriptionResponseMessageBaseResponse}
     * @memberof BritboxAPIAccountModelsCustomerAddSubscriptionResponse
     */
    response?: BritboxDataEvergentModelsAddSubscriptionResponseMessageBaseResponse;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsCustomerGetProductsResponse
 */
export interface BritboxAPIAccountModelsCustomerGetProductsResponse {
    /**
     *
     * @type {BritboxDataEvergentModelsGetProductsResponseMessageBaseResponse}
     * @memberof BritboxAPIAccountModelsCustomerGetProductsResponse
     */
    response?: BritboxDataEvergentModelsGetProductsResponseMessageBaseResponse;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsDeviceGenerateDeviceActivationCodeRequest
 */
export interface BritboxAPIAccountModelsDeviceGenerateDeviceActivationCodeRequest {
    /**
     *
     * @type {BritboxDataEvergentModelsDeviceDetails}
     * @memberof BritboxAPIAccountModelsDeviceGenerateDeviceActivationCodeRequest
     */
    deviceDetails?: BritboxDataEvergentModelsDeviceDetails;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsDeviceGenerateDeviceActivationCodeResponse
 */
export interface BritboxAPIAccountModelsDeviceGenerateDeviceActivationCodeResponse {
    /**
     *
     * @type {BritboxDataEvergentModelsGenerateDeviceActivationCodeResponseMessageBaseResponse}
     * @memberof BritboxAPIAccountModelsDeviceGenerateDeviceActivationCodeResponse
     */
    response?: BritboxDataEvergentModelsGenerateDeviceActivationCodeResponseMessageBaseResponse;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsDeviceRegisterDeviceRequest
 */
export interface BritboxAPIAccountModelsDeviceRegisterDeviceRequest {
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsDeviceRegisterDeviceRequest
     */
    activationCode?: string;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsDeviceRegisterDeviceResponse
 */
export interface BritboxAPIAccountModelsDeviceRegisterDeviceResponse {
    /**
     *
     * @type {BritboxDataEvergentModelsRegisterDeviceResponseMessageBaseResponse}
     * @memberof BritboxAPIAccountModelsDeviceRegisterDeviceResponse
     */
    response?: BritboxDataEvergentModelsRegisterDeviceResponseMessageBaseResponse;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsMediaFileGetItemMediaFilesResponse
 */
export interface BritboxAPIAccountModelsMediaFileGetItemMediaFilesResponse {
    /**
     *
     * @type {Array<BritboxAPIAccountModelsMediaFileGetItemMediaFilesResponseResponse>}
     * @memberof BritboxAPIAccountModelsMediaFileGetItemMediaFilesResponse
     */
    externalResponse?: Array<BritboxAPIAccountModelsMediaFileGetItemMediaFilesResponseResponse>;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsMediaFileGetItemMediaFilesResponse
     */
    errors?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsMediaFileGetItemMediaFilesResponse
     */
    messages?: Array<string>;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsMediaFileGetItemMediaFilesResponseResponse
 */
export interface BritboxAPIAccountModelsMediaFileGetItemMediaFilesResponseResponse {
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsMediaFileGetItemMediaFilesResponseResponse
     */
    token?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsMediaFileGetItemMediaFilesResponseResponse
     */
    url?: string;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsProfileBookmarkItemResponse
 */
export interface BritboxAPIAccountModelsProfileBookmarkItemResponse {
    /**
     *
     * @type {MassiveSDKModelBookmark}
     * @memberof BritboxAPIAccountModelsProfileBookmarkItemResponse
     */
    externalResponse?: MassiveSDKModelBookmark;
    /**
     *
     * @type {MassiveSDKModelItemDetail}
     * @memberof BritboxAPIAccountModelsProfileBookmarkItemResponse
     */
    itemDetail?: MassiveSDKModelItemDetail;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileBookmarkItemResponse
     */
    errors?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileBookmarkItemResponse
     */
    messages?: Array<string>;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsProfileCheckParentalControlResponse
 */
export interface BritboxAPIAccountModelsProfileCheckParentalControlResponse {
    /**
     *
     * @type {boolean}
     * @memberof BritboxAPIAccountModelsProfileCheckParentalControlResponse
     */
    canStream?: boolean;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsProfileDeleteWatchedRequest
 */
export interface BritboxAPIAccountModelsProfileDeleteWatchedRequest {
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileDeleteWatchedRequest
     */
    itemIds?: Array<string>;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsProfileGetBookmarkListResponse
 */
export interface BritboxAPIAccountModelsProfileGetBookmarkListResponse {
    /**
     *
     * @type {MassiveSDKModelItemList}
     * @memberof BritboxAPIAccountModelsProfileGetBookmarkListResponse
     */
    externalResponse?: MassiveSDKModelItemList;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileGetBookmarkListResponse
     */
    errors?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileGetBookmarkListResponse
     */
    messages?: Array<string>;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsProfileGetBookmarksResponse
 */
export interface BritboxAPIAccountModelsProfileGetBookmarksResponse {
    /**
     *
     * @type {{ [key: string]: Date; }}
     * @memberof BritboxAPIAccountModelsProfileGetBookmarksResponse
     */
    externalResponse?: { [key: string]: Date; };
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileGetBookmarksResponse
     */
    errors?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileGetBookmarksResponse
     */
    messages?: Array<string>;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsProfileGetContinueWatchingListResponse
 */
export interface BritboxAPIAccountModelsProfileGetContinueWatchingListResponse {
    /**
     *
     * @type {MassiveSDKModelItemList}
     * @memberof BritboxAPIAccountModelsProfileGetContinueWatchingListResponse
     */
    externalResponse?: MassiveSDKModelItemList;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileGetContinueWatchingListResponse
     */
    errors?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileGetContinueWatchingListResponse
     */
    messages?: Array<string>;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsProfileGetItemBookmarkResponse
 */
export interface BritboxAPIAccountModelsProfileGetItemBookmarkResponse {
    /**
     *
     * @type {MassiveSDKModelBookmark}
     * @memberof BritboxAPIAccountModelsProfileGetItemBookmarkResponse
     */
    externalResponse?: MassiveSDKModelBookmark;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileGetItemBookmarkResponse
     */
    errors?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileGetItemBookmarkResponse
     */
    messages?: Array<string>;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsProfileGetItemWatchedStatusResponse
 */
export interface BritboxAPIAccountModelsProfileGetItemWatchedStatusResponse {
    /**
     *
     * @type {MassiveSDKModelWatched}
     * @memberof BritboxAPIAccountModelsProfileGetItemWatchedStatusResponse
     */
    externalResponse?: MassiveSDKModelWatched;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileGetItemWatchedStatusResponse
     */
    errors?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileGetItemWatchedStatusResponse
     */
    messages?: Array<string>;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsProfileGetNextPlaybackItemResponse
 */
export interface BritboxAPIAccountModelsProfileGetNextPlaybackItemResponse {
    /**
     *
     * @type {MassiveSDKModelNextPlaybackItem}
     * @memberof BritboxAPIAccountModelsProfileGetNextPlaybackItemResponse
     */
    externalResponse?: MassiveSDKModelNextPlaybackItem;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileGetNextPlaybackItemResponse
     */
    errors?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileGetNextPlaybackItemResponse
     */
    messages?: Array<string>;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsProfileGetParentalControlDetailsResponse
 */
export interface BritboxAPIAccountModelsProfileGetParentalControlDetailsResponse {
    /**
     *
     * @type {BritboxDataEvergentModelsGetParentalControlDetailsResponseMessageBase}
     * @memberof BritboxAPIAccountModelsProfileGetParentalControlDetailsResponse
     */
    response?: BritboxDataEvergentModelsGetParentalControlDetailsResponseMessageBase;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsProfileGetProfileResponse
 */
export interface BritboxAPIAccountModelsProfileGetProfileResponse {
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsProfileGetProfileResponse
     */
    firstName?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsProfileGetProfileResponse
     */
    country?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsProfileGetProfileResponse
     */
    status?: string;
    /**
     *
     * @type {{ [key: string]: MassiveSDKModelWatched; }}
     * @memberof BritboxAPIAccountModelsProfileGetProfileResponse
     */
    watched?: { [key: string]: MassiveSDKModelWatched; };
    /**
     *
     * @type {MassiveSDKModelItemList}
     * @memberof BritboxAPIAccountModelsProfileGetProfileResponse
     */
    watchedList?: MassiveSDKModelItemList;
    /**
     *
     * @type {{ [key: string]: Date; }}
     * @memberof BritboxAPIAccountModelsProfileGetProfileResponse
     */
    bookmarks?: { [key: string]: Date; };
    /**
     *
     * @type {MassiveSDKModelItemList}
     * @memberof BritboxAPIAccountModelsProfileGetProfileResponse
     */
    bookmarkList?: MassiveSDKModelItemList;
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsProfileGetProfileResponse
     */
    subscriptionStatus?: string;
    /**
     *
     * @type {boolean}
     * @memberof BritboxAPIAccountModelsProfileGetProfileResponse
     */
    isInFreeTrail?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof BritboxAPIAccountModelsProfileGetProfileResponse
     */
    canStream?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof BritboxAPIAccountModelsProfileGetProfileResponse
     */
    parentalControl?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileGetProfileResponse
     */
    errors?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileGetProfileResponse
     */
    messages?: Array<string>;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsProfileGetWatchedListResponse
 */
export interface BritboxAPIAccountModelsProfileGetWatchedListResponse {
    /**
     *
     * @type {MassiveSDKModelItemList}
     * @memberof BritboxAPIAccountModelsProfileGetWatchedListResponse
     */
    externalResponse?: MassiveSDKModelItemList;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileGetWatchedListResponse
     */
    errors?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileGetWatchedListResponse
     */
    messages?: Array<string>;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsProfileGetWatchedResponse
 */
export interface BritboxAPIAccountModelsProfileGetWatchedResponse {
    /**
     *
     * @type {{ [key: string]: MassiveSDKModelWatched; }}
     * @memberof BritboxAPIAccountModelsProfileGetWatchedResponse
     */
    externalResponse?: { [key: string]: MassiveSDKModelWatched; };
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileGetWatchedResponse
     */
    errors?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileGetWatchedResponse
     */
    messages?: Array<string>;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsProfileSetItemWatchedStatusRequest
 */
export interface BritboxAPIAccountModelsProfileSetItemWatchedStatusRequest {
    /**
     *
     * @type {number}
     * @memberof BritboxAPIAccountModelsProfileSetItemWatchedStatusRequest
     */
    position: number;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsProfileSetItemWatchedStatusResponse
 */
export interface BritboxAPIAccountModelsProfileSetItemWatchedStatusResponse {
    /**
     *
     * @type {MassiveSDKModelWatched}
     * @memberof BritboxAPIAccountModelsProfileSetItemWatchedStatusResponse
     */
    externalResponse?: MassiveSDKModelWatched;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileSetItemWatchedStatusResponse
     */
    errors?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof BritboxAPIAccountModelsProfileSetItemWatchedStatusResponse
     */
    messages?: Array<string>;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsProfileUpdateParentalControlDetailsRequest
 */
export interface BritboxAPIAccountModelsProfileUpdateParentalControlDetailsRequest {
    /**
     * Active or deactivate the parental control. true or false.
     * @type {string}
     * @memberof BritboxAPIAccountModelsProfileUpdateParentalControlDetailsRequest
     */
    parentalControl?: string;
    /**
     * Level of the parental control.
     * @type {number}
     * @memberof BritboxAPIAccountModelsProfileUpdateParentalControlDetailsRequest
     */
    parentalControlLevel?: number;
    /**
     * Secure pin of parental control.
     * @type {string}
     * @memberof BritboxAPIAccountModelsProfileUpdateParentalControlDetailsRequest
     */
    newParentalControlPin?: string;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsProfileUpdateParentalControlDetailsResponse
 */
export interface BritboxAPIAccountModelsProfileUpdateParentalControlDetailsResponse {
    /**
     *
     * @type {BritboxDataEvergentModelsUpdateParentalControlDetailsResponseMessageBase}
     * @memberof BritboxAPIAccountModelsProfileUpdateParentalControlDetailsResponse
     */
    response?: BritboxDataEvergentModelsUpdateParentalControlDetailsResponseMessageBase;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsProfileValidateParentalControlPINRequest
 */
export interface BritboxAPIAccountModelsProfileValidateParentalControlPINRequest {
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsProfileValidateParentalControlPINRequest
     */
    parentalControlPin?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsProfileValidateParentalControlPINRequest
     */
    itemId?: string;
}

/**
 *
 * @export
 * @interface BritboxAPIAccountModelsProfileValidateParentalControlPINResponse
 */
export interface BritboxAPIAccountModelsProfileValidateParentalControlPINResponse {
    /**
     *
     * @type {BritboxDataEvergentModelsValidateParentalControlPINResponseMessageBase}
     * @memberof BritboxAPIAccountModelsProfileValidateParentalControlPINResponse
     */
    response?: BritboxDataEvergentModelsValidateParentalControlPINResponseMessageBase;
    /**
     *
     * @type {string}
     * @memberof BritboxAPIAccountModelsProfileValidateParentalControlPINResponse
     */
    token?: string;
}

/**
 *
 * @export
 * @interface BritboxDataEvergentModelsAddSubscriptionRequestMessage
 */
export interface BritboxDataEvergentModelsAddSubscriptionRequestMessage {
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsAddSubscriptionRequestMessage
     */
    appServiceID?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsAddSubscriptionRequestMessage
     */
    serviceType?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsAddSubscriptionRequestMessage
     */
    rateType?: string;
    /**
     *
     * @type {number}
     * @memberof BritboxDataEvergentModelsAddSubscriptionRequestMessage
     */
    priceCharged?: number;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsAddSubscriptionRequestMessage
     */
    amazonUserId?: string;
    /**
     *
     * @type {BritboxDataEvergentModelsPaymentMethodInfo}
     * @memberof BritboxDataEvergentModelsAddSubscriptionRequestMessage
     */
    paymentMethodInfo?: BritboxDataEvergentModelsPaymentMethodInfo;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsAddSubscriptionRequestMessage
     */
    channelPartnerID?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsAddSubscriptionRequestMessage
     */
    apiKey?: string;
}

/**
 *
 * @export
 * @interface BritboxDataEvergentModelsAddSubscriptionResponseMessageBaseResponse
 */
export interface BritboxDataEvergentModelsAddSubscriptionResponseMessageBaseResponse {
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsAddSubscriptionResponseMessageBaseResponse
     */
    orderId?: string;
    /**
     *
     * @type {number}
     * @memberof BritboxDataEvergentModelsAddSubscriptionResponseMessageBaseResponse
     */
    validityTill?: number;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsAddSubscriptionResponseMessageBaseResponse
     */
    message?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsAddSubscriptionResponseMessageBaseResponse
     */
    responseCode?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsAddSubscriptionResponseMessageBaseResponse
     */
    status?: string;
    /**
     *
     * @type {Array<BritboxDataEvergentModelsFailureMessage>}
     * @memberof BritboxDataEvergentModelsAddSubscriptionResponseMessageBaseResponse
     */
    failureMessage?: Array<BritboxDataEvergentModelsFailureMessage>;
}

/**
 *
 * @export
 * @interface BritboxDataEvergentModelsDeviceDetails
 */
export interface BritboxDataEvergentModelsDeviceDetails {
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsDeviceDetails
     */
    serialNo?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsDeviceDetails
     */
    deviceType?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsDeviceDetails
     */
    deviceName?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsDeviceDetails
     */
    modelNo?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsDeviceDetails
     */
    brand?: string;
}

/**
 *
 * @export
 * @interface BritboxDataEvergentModelsFailureMessage
 */
export interface BritboxDataEvergentModelsFailureMessage {
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsFailureMessage
     */
    errorMessage?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsFailureMessage
     */
    errorCode?: string;
}

/**
 *
 * @export
 * @interface BritboxDataEvergentModelsGenerateDeviceActivationCodeResponseMessageBaseResponse
 */
export interface BritboxDataEvergentModelsGenerateDeviceActivationCodeResponseMessageBaseResponse {
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGenerateDeviceActivationCodeResponseMessageBaseResponse
     */
    activationCode?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGenerateDeviceActivationCodeResponseMessageBaseResponse
     */
    message?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGenerateDeviceActivationCodeResponseMessageBaseResponse
     */
    responseCode?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGenerateDeviceActivationCodeResponseMessageBaseResponse
     */
    status?: string;
    /**
     *
     * @type {Array<BritboxDataEvergentModelsFailureMessage>}
     * @memberof BritboxDataEvergentModelsGenerateDeviceActivationCodeResponseMessageBaseResponse
     */
    failureMessage?: Array<BritboxDataEvergentModelsFailureMessage>;
}

/**
 *
 * @export
 * @interface BritboxDataEvergentModelsGetParentalControlDetailsResponseMessageBase
 */
export interface BritboxDataEvergentModelsGetParentalControlDetailsResponseMessageBase {
    /**
     *
     * @type {BritboxDataEvergentModelsGetParentalControlDetailsResponseMessageBaseResponse}
     * @memberof BritboxDataEvergentModelsGetParentalControlDetailsResponseMessageBase
     */
    getParentalControlDetailsResponseMessage?: BritboxDataEvergentModelsGetParentalControlDetailsResponseMessageBaseResponse;
}

/**
 *
 * @export
 * @interface BritboxDataEvergentModelsGetParentalControlDetailsResponseMessageBaseResponse
 */
export interface BritboxDataEvergentModelsGetParentalControlDetailsResponseMessageBaseResponse {
    /**
     *
     * @type {number}
     * @memberof BritboxDataEvergentModelsGetParentalControlDetailsResponseMessageBaseResponse
     */
    parentalControlLevel?: number;
    /**
     *
     * @type {boolean}
     * @memberof BritboxDataEvergentModelsGetParentalControlDetailsResponseMessageBaseResponse
     */
    parentalControl?: boolean;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetParentalControlDetailsResponseMessageBaseResponse
     */
    parentalControlPIN?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetParentalControlDetailsResponseMessageBaseResponse
     */
    message?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetParentalControlDetailsResponseMessageBaseResponse
     */
    responseCode?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetParentalControlDetailsResponseMessageBaseResponse
     */
    status?: string;
    /**
     *
     * @type {Array<BritboxDataEvergentModelsFailureMessage>}
     * @memberof BritboxDataEvergentModelsGetParentalControlDetailsResponseMessageBaseResponse
     */
    failureMessage?: Array<BritboxDataEvergentModelsFailureMessage>;
}

/**
 *
 * @export
 * @interface BritboxDataEvergentModelsGetProductsResponseMessageBaseAppChannels
 */
export interface BritboxDataEvergentModelsGetProductsResponseMessageBaseAppChannels {
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseAppChannels
     */
    appName?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseAppChannels
     */
    appChannel?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseAppChannels
     */
    appID?: string;
}

/**
 *
 * @export
 * @interface BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg
 */
export interface BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg {
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg
     */
    dmaName?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg
     */
    duration?: string;
    /**
     *
     * @type {number}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg
     */
    retailPrice?: number;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg
     */
    currencyCode?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg
     */
    productDescription?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg
     */
    productCategory?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg
     */
    serviceType?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg
     */
    currencySymbol?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg
     */
    displayOrder?: string;
    /**
     *
     * @type {boolean}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg
     */
    isAdsEnabled?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg
     */
    renewable?: boolean;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg
     */
    displayName?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg
     */
    period?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg
     */
    productName?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg
     */
    skuORQuickCode?: string;
    /**
     *
     * @type {boolean}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg
     */
    basicService?: boolean;
    /**
     *
     * @type {Array<BritboxDataEvergentModelsGetProductsResponseMessageBaseAppChannels>}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg
     */
    appChannels?: Array<BritboxDataEvergentModelsGetProductsResponseMessageBaseAppChannels>;
    /**
     *
     * @type {Array<BritboxDataEvergentModelsGetProductsResponseMessageBaseSCOfferTypes>}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg
     */
    scOfferTypes?: Array<BritboxDataEvergentModelsGetProductsResponseMessageBaseSCOfferTypes>;
    /**
     *
     * @type {Array<BritboxDataEvergentModelsGetProductsResponseMessageBasePromotions>}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg
     */
    promotions?: Array<BritboxDataEvergentModelsGetProductsResponseMessageBasePromotions>;
}

/**
 *
 * @export
 * @interface BritboxDataEvergentModelsGetProductsResponseMessageBasePromotions
 */
export interface BritboxDataEvergentModelsGetProductsResponseMessageBasePromotions {
    /**
     *
     * @type {number}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBasePromotions
     */
    amount?: number;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBasePromotions
     */
    promotionId?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBasePromotions
     */
    promotionName?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBasePromotions
     */
    promotionType?: string;
    /**
     *
     * @type {boolean}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBasePromotions
     */
    isVODPromotion?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBasePromotions
     */
    isFreeTrial?: boolean;
    /**
     *
     * @type {number}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBasePromotions
     */
    promotionExpiryfferType?: number;
    /**
     *
     * @type {number}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBasePromotions
     */
    promotionDuration?: number;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBasePromotions
     */
    promotionPeriod?: string;
}

/**
 *
 * @export
 * @interface BritboxDataEvergentModelsGetProductsResponseMessageBaseResponse
 */
export interface BritboxDataEvergentModelsGetProductsResponseMessageBaseResponse {
    /**
     *
     * @type {Array<BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg>}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseResponse
     */
    productsResponseMessage?: Array<BritboxDataEvergentModelsGetProductsResponseMessageBaseProductsResponseMsg>;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseResponse
     */
    message?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseResponse
     */
    responseCode?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseResponse
     */
    status?: string;
    /**
     *
     * @type {Array<BritboxDataEvergentModelsFailureMessage>}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseResponse
     */
    failureMessage?: Array<BritboxDataEvergentModelsFailureMessage>;
}

/**
 *
 * @export
 * @interface BritboxDataEvergentModelsGetProductsResponseMessageBaseSCOfferTypes
 */
export interface BritboxDataEvergentModelsGetProductsResponseMessageBaseSCOfferTypes {
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseSCOfferTypes
     */
    offerType?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsGetProductsResponseMessageBaseSCOfferTypes
     */
    salesChannel?: string;
}

/**
 *
 * @export
 * @interface BritboxDataEvergentModelsPaymentMethodInfo
 */
export interface BritboxDataEvergentModelsPaymentMethodInfo {
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsPaymentMethodInfo
     */
    label?: string;
    /**
     *
     * @type {BritboxDataEvergentModelsTransactionReferenceMsg}
     * @memberof BritboxDataEvergentModelsPaymentMethodInfo
     */
    transactionReferenceMsg?: BritboxDataEvergentModelsTransactionReferenceMsg;
}

/**
 *
 * @export
 * @interface BritboxDataEvergentModelsRefreshTokenResponseMessageBaseResponse
 */
export interface BritboxDataEvergentModelsRefreshTokenResponseMessageBaseResponse {
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsRefreshTokenResponseMessageBaseResponse
     */
    accessToken?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsRefreshTokenResponseMessageBaseResponse
     */
    refreshToken?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsRefreshTokenResponseMessageBaseResponse
     */
    tokenType?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsRefreshTokenResponseMessageBaseResponse
     */
    expiresIn?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsRefreshTokenResponseMessageBaseResponse
     */
    message?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsRefreshTokenResponseMessageBaseResponse
     */
    responseCode?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsRefreshTokenResponseMessageBaseResponse
     */
    status?: string;
    /**
     *
     * @type {Array<BritboxDataEvergentModelsFailureMessage>}
     * @memberof BritboxDataEvergentModelsRefreshTokenResponseMessageBaseResponse
     */
    failureMessage?: Array<BritboxDataEvergentModelsFailureMessage>;
}

/**
 *
 * @export
 * @interface BritboxDataEvergentModelsRegisterDeviceResponseMessageBaseResponse
 */
export interface BritboxDataEvergentModelsRegisterDeviceResponseMessageBaseResponse {
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsRegisterDeviceResponseMessageBaseResponse
     */
    message?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsRegisterDeviceResponseMessageBaseResponse
     */
    responseCode?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsRegisterDeviceResponseMessageBaseResponse
     */
    status?: string;
    /**
     *
     * @type {BritboxDataEvergentModelsFailureMessage}
     * @memberof BritboxDataEvergentModelsRegisterDeviceResponseMessageBaseResponse
     */
    failureMessage?: BritboxDataEvergentModelsFailureMessage;
}

/**
 *
 * @export
 * @interface BritboxDataEvergentModelsTransactionReferenceMsg
 */
export interface BritboxDataEvergentModelsTransactionReferenceMsg {
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsTransactionReferenceMsg
     */
    amount?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsTransactionReferenceMsg
     */
    txID?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsTransactionReferenceMsg
     */
    txMsg?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsTransactionReferenceMsg
     */
    rokuPucId?: string;
}

/**
 *
 * @export
 * @interface BritboxDataEvergentModelsUpdateParentalControlDetailsResponseMessageBase
 */
export interface BritboxDataEvergentModelsUpdateParentalControlDetailsResponseMessageBase {
    /**
     *
     * @type {BritboxDataEvergentModelsUpdateParentalControlDetailsResponseMessageBaseResponse}
     * @memberof BritboxDataEvergentModelsUpdateParentalControlDetailsResponseMessageBase
     */
    updateParentalControlDetailsResponseMessage?: BritboxDataEvergentModelsUpdateParentalControlDetailsResponseMessageBaseResponse;
}

/**
 *
 * @export
 * @interface BritboxDataEvergentModelsUpdateParentalControlDetailsResponseMessageBaseResponse
 */
export interface BritboxDataEvergentModelsUpdateParentalControlDetailsResponseMessageBaseResponse {
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsUpdateParentalControlDetailsResponseMessageBaseResponse
     */
    message?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsUpdateParentalControlDetailsResponseMessageBaseResponse
     */
    responseCode?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsUpdateParentalControlDetailsResponseMessageBaseResponse
     */
    status?: string;
    /**
     *
     * @type {Array<BritboxDataEvergentModelsFailureMessage>}
     * @memberof BritboxDataEvergentModelsUpdateParentalControlDetailsResponseMessageBaseResponse
     */
    failureMessage?: Array<BritboxDataEvergentModelsFailureMessage>;
}

/**
 *
 * @export
 * @interface BritboxDataEvergentModelsValidateParentalControlPINResponseMessageBase
 */
export interface BritboxDataEvergentModelsValidateParentalControlPINResponseMessageBase {
    /**
     *
     * @type {BritboxDataEvergentModelsValidateParentalControlPINResponseMessageBaseResponse}
     * @memberof BritboxDataEvergentModelsValidateParentalControlPINResponseMessageBase
     */
    validateParentalControlPINResponseMessage?: BritboxDataEvergentModelsValidateParentalControlPINResponseMessageBaseResponse;
}

/**
 *
 * @export
 * @interface BritboxDataEvergentModelsValidateParentalControlPINResponseMessageBaseResponse
 */
export interface BritboxDataEvergentModelsValidateParentalControlPINResponseMessageBaseResponse {
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsValidateParentalControlPINResponseMessageBaseResponse
     */
    message?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsValidateParentalControlPINResponseMessageBaseResponse
     */
    responseCode?: string;
    /**
     *
     * @type {string}
     * @memberof BritboxDataEvergentModelsValidateParentalControlPINResponseMessageBaseResponse
     */
    status?: string;
    /**
     *
     * @type {Array<BritboxDataEvergentModelsFailureMessage>}
     * @memberof BritboxDataEvergentModelsValidateParentalControlPINResponseMessageBaseResponse
     */
    failureMessage?: Array<BritboxDataEvergentModelsFailureMessage>;
}

/**
 *
 * @export
 * @interface MassiveSDKModelBookmark
 */
export interface MassiveSDKModelBookmark {
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelBookmark
     */
    itemId?: string;
    /**
     *
     * @type {Date}
     * @memberof MassiveSDKModelBookmark
     */
    creationDate?: Date;
}

/**
 *
 * @export
 * @interface MassiveSDKModelClassification
 */
export interface MassiveSDKModelClassification {
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelClassification
     */
    code?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelClassification
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelClassification
     */
    advisoryText?: string;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelClassification
     */
    level?: number;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelClassification
     */
    system?: string;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof MassiveSDKModelClassification
     */
    images?: { [key: string]: string; };
}

/**
 *
 * @export
 * @interface MassiveSDKModelClassificationSummary
 */
export interface MassiveSDKModelClassificationSummary {
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelClassificationSummary
     */
    code?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelClassificationSummary
     */
    name?: string;
}

/**
 *
 * @export
 * @interface MassiveSDKModelContinueWatchingListData
 */
export interface MassiveSDKModelContinueWatchingListData {
    /**
     *
     * @type {{ [key: string]: MassiveSDKModelContinueWatchingListDataExpansion; }}
     * @memberof MassiveSDKModelContinueWatchingListData
     */
    itemInclusions?: { [key: string]: MassiveSDKModelContinueWatchingListDataExpansion; };
}

/**
 *
 * @export
 * @interface MassiveSDKModelContinueWatchingListDataExpansion
 */
export interface MassiveSDKModelContinueWatchingListDataExpansion {
    /**
     *
     * @type {MassiveSDKModelItemSummary}
     * @memberof MassiveSDKModelContinueWatchingListDataExpansion
     */
    episode?: MassiveSDKModelItemSummary;
    /**
     *
     * @type {MassiveSDKModelItemSummary}
     * @memberof MassiveSDKModelContinueWatchingListDataExpansion
     */
    season?: MassiveSDKModelItemSummary;
    /**
     *
     * @type {MassiveSDKModelItemSummary}
     * @memberof MassiveSDKModelContinueWatchingListDataExpansion
     */
    show?: MassiveSDKModelItemSummary;
}

/**
 *
 * @export
 * @interface MassiveSDKModelCredit
 */
export interface MassiveSDKModelCredit {
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelCredit
     */
    role?: MassiveSDKModelCredit.RoleEnum;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelCredit
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelCredit
     */
    path?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelCredit
     */
    character?: string;
}

/**
 * @export
 * @namespace MassiveSDKModelCredit
 */
export namespace MassiveSDKModelCredit {
    /**
     * @export
     * @enum {string}
     */
    export enum RoleEnum {
        Actor = <any> 'actor',
        Associateproducer = <any> 'associateproducer',
        Coactor = <any> 'coactor',
        Director = <any> 'director',
        Executiveproducer = <any> 'executiveproducer',
        Filminglocation = <any> 'filminglocation',
        Guest = <any> 'guest',
        Narrator = <any> 'narrator',
        Other = <any> 'other',
        Presenter = <any> 'presenter',
        Producer = <any> 'producer',
        Productmanager = <any> 'productmanager',
        Thememusicby = <any> 'thememusicby',
        Voice = <any> 'voice',
        Writer = <any> 'writer'
    }
}

/**
 *
 * @export
 * @interface MassiveSDKModelEpisodes
 */
export interface MassiveSDKModelEpisodes {
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelEpisodes
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelEpisodes
     */
    path?: string;
    /**
     *
     * @type {Array<MassiveSDKModelEpisodesItem>}
     * @memberof MassiveSDKModelEpisodes
     */
    items?: Array<MassiveSDKModelEpisodesItem>;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelEpisodes
     */
    size?: number;
    /**
     *
     * @type {MassiveSDKModelPaging}
     * @memberof MassiveSDKModelEpisodes
     */
    paging?: MassiveSDKModelPaging;
}

/**
 *
 * @export
 * @interface MassiveSDKModelEpisodesItem
 */
export interface MassiveSDKModelEpisodesItem {
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof MassiveSDKModelEpisodesItem
     */
    images?: { [key: string]: string; };
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelEpisodesItem
     */
    duration?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelEpisodesItem
     */
    releaseYear?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelEpisodesItem
     */
    episodeNumber?: number;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelEpisodesItem
     */
    episodeName?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelEpisodesItem
     */
    seasonId?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelEpisodesItem
     */
    showId?: string;
    /**
     *
     * @type {Array<MassiveSDKModelOffer>}
     * @memberof MassiveSDKModelEpisodesItem
     */
    offers?: Array<MassiveSDKModelOffer>;
    /**
     *
     * @type {Array<string>}
     * @memberof MassiveSDKModelEpisodesItem
     */
    scopes?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof MassiveSDKModelEpisodesItem
     */
    categories?: Array<string>;
    /**
     *
     * @type {any}
     * @memberof MassiveSDKModelEpisodesItem
     */
    customFields?: any;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelEpisodesItem
     */
    customId?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof MassiveSDKModelEpisodesItem
     */
    genres?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelEpisodesItem
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelEpisodesItem
     */
    type?: string;
    /**
     *
     * @type {Date}
     * @memberof MassiveSDKModelEpisodesItem
     */
    maximumOfferEnd?: Date;
    /**
     *
     * @type {Array<MassiveSDKModelMedia>}
     * @memberof MassiveSDKModelEpisodesItem
     */
    media?: Array<MassiveSDKModelMedia>;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelEpisodesItem
     */
    shortDescription?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelEpisodesItem
     */
    contextualTitle?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelEpisodesItem
     */
    title?: string;
    /**
     *
     * @type {MassiveSDKModelClassification}
     * @memberof MassiveSDKModelEpisodesItem
     */
    classification?: MassiveSDKModelClassification;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelEpisodesItem
     */
    totalUserRatings?: number;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelEpisodesItem
     */
    path?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelEpisodesItem
     */
    watchPath?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelEpisodesItem
     */
    showTitle?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelEpisodesItem
     */
    seasonTitle?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelEpisodesItem
     */
    badge?: string;
}

/**
 *
 * @export
 * @interface MassiveSDKModelExclusionRule
 */
export interface MassiveSDKModelExclusionRule {
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelExclusionRule
     */
    excludeDelivery?: MassiveSDKModelExclusionRule.ExcludeDeliveryEnum;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelExclusionRule
     */
    excludeMinResolution?: MassiveSDKModelExclusionRule.ExcludeMinResolutionEnum;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelExclusionRule
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelExclusionRule
     */
    device?: string;
    /**
     *
     * @type {boolean}
     * @memberof MassiveSDKModelExclusionRule
     */
    excludeAirplay?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof MassiveSDKModelExclusionRule
     */
    excludeChromecast?: boolean;
}

/**
 * @export
 * @namespace MassiveSDKModelExclusionRule
 */
export namespace MassiveSDKModelExclusionRule {
    /**
     * @export
     * @enum {string}
     */
    export enum ExcludeDeliveryEnum {
        Stream = <any> 'Stream',
        Download = <any> 'Download',
        StreamOrDownload = <any> 'StreamOrDownload',
        ProgressiveDownload = <any> 'ProgressiveDownload',
        None = <any> 'None'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ExcludeMinResolutionEnum {
        SD = <any> 'SD',
        HD720 = <any> 'HD-720',
        HD1080 = <any> 'HD-1080',
        HD4K = <any> 'HD-4K',
        External = <any> 'External',
        Unknown = <any> 'Unknown'
    }
}

/**
 *
 * @export
 * @interface MassiveSDKModelItemCustomMetadata
 */
export interface MassiveSDKModelItemCustomMetadata {
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemCustomMetadata
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemCustomMetadata
     */
    value?: string;
}

/**
 *
 * @export
 * @interface MassiveSDKModelItemDetail
 */
export interface MassiveSDKModelItemDetail {
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    advisoryText?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    copyright?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    distributor?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    description?: string;
    /**
     *
     * @type {Array<MassiveSDKModelItemCustomMetadata>}
     * @memberof MassiveSDKModelItemDetail
     */
    customMetadata?: Array<MassiveSDKModelItemCustomMetadata>;
    /**
     *
     * @type {Array<string>}
     * @memberof MassiveSDKModelItemDetail
     */
    genrePaths?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    location?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    venue?: string;
    /**
     *
     * @type {Date}
     * @memberof MassiveSDKModelItemDetail
     */
    eventDate?: Date;
    /**
     *
     * @type {Array<MassiveSDKModelCredit>}
     * @memberof MassiveSDKModelItemDetail
     */
    credits?: Array<MassiveSDKModelCredit>;
    /**
     *
     * @type {MassiveSDKModelItemList}
     * @memberof MassiveSDKModelItemDetail
     */
    seasons?: MassiveSDKModelItemList;
    /**
     *
     * @type {MassiveSDKModelItemList}
     * @memberof MassiveSDKModelItemDetail
     */
    episodes?: MassiveSDKModelItemList;
    /**
     *
     * @type {MassiveSDKModelItemDetail}
     * @memberof MassiveSDKModelItemDetail
     */
    season?: MassiveSDKModelItemDetail;
    /**
     *
     * @type {MassiveSDKModelItemDetail}
     * @memberof MassiveSDKModelItemDetail
     */
    show?: MassiveSDKModelItemDetail;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelItemDetail
     */
    totalUserRatings?: number;
    /**
     *
     * @type {Array<MassiveSDKModelItemSummary>}
     * @memberof MassiveSDKModelItemDetail
     */
    trailers?: Array<MassiveSDKModelItemSummary>;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    type?: MassiveSDKModelItemDetail.TypeEnum;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    subtype?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    contextualTitle?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    shortDescription?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    tagline?: string;
    /**
     *
     * @type {MassiveSDKModelClassificationSummary}
     * @memberof MassiveSDKModelItemDetail
     */
    classification?: MassiveSDKModelClassificationSummary;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    path?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    watchPath?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof MassiveSDKModelItemDetail
     */
    scopes?: Array<string>;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelItemDetail
     */
    releaseYear?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelItemDetail
     */
    episodeCount?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelItemDetail
     */
    availableEpisodeCount?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelItemDetail
     */
    availableSeasonCount?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelItemDetail
     */
    seasonNumber?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelItemDetail
     */
    episodeNumber?: number;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    episodeName?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    showId?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    showTitle?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    seasonId?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    seasonTitle?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    channelShortCode?: string;
    /**
     *
     * @type {boolean}
     * @memberof MassiveSDKModelItemDetail
     */
    hasClosedCaptions?: boolean;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelItemDetail
     */
    averageUserRating?: number;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    badge?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof MassiveSDKModelItemDetail
     */
    genres?: Array<string>;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelItemDetail
     */
    duration?: number;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemDetail
     */
    customId?: string;
    /**
     *
     * @type {Array<MassiveSDKModelOffer>}
     * @memberof MassiveSDKModelItemDetail
     */
    offers?: Array<MassiveSDKModelOffer>;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof MassiveSDKModelItemDetail
     */
    images?: { [key: string]: string; };
    /**
     *
     * @type {Array<MassiveSDKModelTheme>}
     * @memberof MassiveSDKModelItemDetail
     */
    themes?: Array<MassiveSDKModelTheme>;
    /**
     *
     * @type {any}
     * @memberof MassiveSDKModelItemDetail
     */
    customFields?: any;
    /**
     *
     * @type {Array<any>}
     * @memberof MassiveSDKModelItemDetail
     */
    vams?: Array<any>;
}

/**
 * @export
 * @namespace MassiveSDKModelItemDetail
 */
export namespace MassiveSDKModelItemDetail {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Movie = <any> 'movie',
        Show = <any> 'show',
        Season = <any> 'season',
        Episode = <any> 'episode',
        Program = <any> 'program',
        Link = <any> 'link',
        Trailer = <any> 'trailer',
        Channel = <any> 'channel',
        CustomAsset = <any> 'customAsset'
    }
}

/**
 *
 * @export
 * @interface MassiveSDKModelItemList
 */
export interface MassiveSDKModelItemList {
    /**
     *
     * @type {Array<string>}
     * @memberof MassiveSDKModelItemList
     */
    itemTypes?: Array<MassiveSDKModelItemList.ItemTypesEnum>;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemList
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemList
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemList
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemList
     */
    shortDescription?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemList
     */
    tagline?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemList
     */
    path?: string;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelItemList
     */
    size?: number;
    /**
     *
     * @type {Array<MassiveSDKModelItemSummary>}
     * @memberof MassiveSDKModelItemList
     */
    items?: Array<MassiveSDKModelItemSummary>;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof MassiveSDKModelItemList
     */
    images?: { [key: string]: string; };
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemList
     */
    parameter?: string;
    /**
     *
     * @type {MassiveSDKModelPagination}
     * @memberof MassiveSDKModelItemList
     */
    paging?: MassiveSDKModelPagination;
    /**
     *
     * @type {any}
     * @memberof MassiveSDKModelItemList
     */
    customFields?: any;
    /**
     *
     * @type {Array<MassiveSDKModelTheme>}
     * @memberof MassiveSDKModelItemList
     */
    themes?: Array<MassiveSDKModelTheme>;
    /**
     *
     * @type {MassiveSDKModelListData}
     * @memberof MassiveSDKModelItemList
     */
    listData?: MassiveSDKModelListData;
}

/**
 * @export
 * @namespace MassiveSDKModelItemList
 */
export namespace MassiveSDKModelItemList {
    /**
     * @export
     * @enum {string}
     */
    export enum ItemTypesEnum {
        Movie = <any> 'movie',
        Show = <any> 'show',
        Season = <any> 'season',
        Episode = <any> 'episode',
        Program = <any> 'program',
        Link = <any> 'link',
        Trailer = <any> 'trailer',
        Channel = <any> 'channel',
        CustomAsset = <any> 'customAsset'
    }
}

/**
 *
 * @export
 * @interface MassiveSDKModelItemSummary
 */
export interface MassiveSDKModelItemSummary {
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemSummary
     */
    type?: MassiveSDKModelItemSummary.TypeEnum;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemSummary
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemSummary
     */
    subtype?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemSummary
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemSummary
     */
    contextualTitle?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemSummary
     */
    shortDescription?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemSummary
     */
    tagline?: string;
    /**
     *
     * @type {MassiveSDKModelClassificationSummary}
     * @memberof MassiveSDKModelItemSummary
     */
    classification?: MassiveSDKModelClassificationSummary;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemSummary
     */
    path?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemSummary
     */
    watchPath?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof MassiveSDKModelItemSummary
     */
    scopes?: Array<string>;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelItemSummary
     */
    releaseYear?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelItemSummary
     */
    episodeCount?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelItemSummary
     */
    availableEpisodeCount?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelItemSummary
     */
    availableSeasonCount?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelItemSummary
     */
    seasonNumber?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelItemSummary
     */
    episodeNumber?: number;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemSummary
     */
    episodeName?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemSummary
     */
    showId?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemSummary
     */
    showTitle?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemSummary
     */
    seasonId?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemSummary
     */
    seasonTitle?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemSummary
     */
    channelShortCode?: string;
    /**
     *
     * @type {boolean}
     * @memberof MassiveSDKModelItemSummary
     */
    hasClosedCaptions?: boolean;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelItemSummary
     */
    averageUserRating?: number;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemSummary
     */
    badge?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof MassiveSDKModelItemSummary
     */
    genres?: Array<string>;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelItemSummary
     */
    duration?: number;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelItemSummary
     */
    customId?: string;
    /**
     *
     * @type {Array<MassiveSDKModelOffer>}
     * @memberof MassiveSDKModelItemSummary
     */
    offers?: Array<MassiveSDKModelOffer>;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof MassiveSDKModelItemSummary
     */
    images?: { [key: string]: string; };
    /**
     *
     * @type {Array<MassiveSDKModelTheme>}
     * @memberof MassiveSDKModelItemSummary
     */
    themes?: Array<MassiveSDKModelTheme>;
    /**
     *
     * @type {any}
     * @memberof MassiveSDKModelItemSummary
     */
    customFields?: any;
    /**
     *
     * @type {MassiveSDKModelShow}
     * @memberof MassiveSDKModelItemSummary
     */
    show?: MassiveSDKModelShow;
    /**
     *
     * @type {MassiveSDKModelEpisodes}
     * @memberof MassiveSDKModelItemSummary
     */
    episodes?: MassiveSDKModelEpisodes;
    /**
     *
     * @type {MassiveSDKModelItemSummary}
     * @memberof MassiveSDKModelItemSummary
     */
    season?: MassiveSDKModelItemSummary;
    /**
     *
     * @type {Array<MassiveSDKModelCredit>}
     * @memberof MassiveSDKModelItemSummary
     */
    credits?: Array<MassiveSDKModelCredit>;
    /**
     *
     * @type {Array<any>}
     * @memberof MassiveSDKModelItemSummary
     */
    vams?: Array<any>;
}

/**
 * @export
 * @namespace MassiveSDKModelItemSummary
 */
export namespace MassiveSDKModelItemSummary {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Movie = <any> 'movie',
        Show = <any> 'show',
        Season = <any> 'season',
        Episode = <any> 'episode',
        Program = <any> 'program',
        Link = <any> 'link',
        Trailer = <any> 'trailer',
        Channel = <any> 'channel',
        CustomAsset = <any> 'customAsset'
    }
}

/**
 *
 * @export
 * @interface MassiveSDKModelListData
 */
export interface MassiveSDKModelListData {
    /**
     *
     * @type {MassiveSDKModelContinueWatchingListData}
     * @memberof MassiveSDKModelListData
     */
    continueWatching?: MassiveSDKModelContinueWatchingListData;
}

/**
 *
 * @export
 * @interface MassiveSDKModelMedia
 */
export interface MassiveSDKModelMedia {
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelMedia
     */
    duration?: number;
}

/**
 *
 * @export
 * @interface MassiveSDKModelNextPlaybackItem
 */
export interface MassiveSDKModelNextPlaybackItem {
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelNextPlaybackItem
     */
    suggestionType?: MassiveSDKModelNextPlaybackItem.SuggestionTypeEnum;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelNextPlaybackItem
     */
    sourceItemId?: string;
    /**
     *
     * @type {Date}
     * @memberof MassiveSDKModelNextPlaybackItem
     */
    firstWatchedDate?: Date;
    /**
     *
     * @type {Date}
     * @memberof MassiveSDKModelNextPlaybackItem
     */
    lastWatchedDate?: Date;
    /**
     *
     * @type {MassiveSDKModelItemDetail}
     * @memberof MassiveSDKModelNextPlaybackItem
     */
    next?: MassiveSDKModelItemDetail;
}

/**
 * @export
 * @namespace MassiveSDKModelNextPlaybackItem
 */
export namespace MassiveSDKModelNextPlaybackItem {
    /**
     * @export
     * @enum {string}
     */
    export enum SuggestionTypeEnum {
        StartWatching = <any> 'StartWatching',
        ContinueWatching = <any> 'ContinueWatching',
        RestartWatching = <any> 'RestartWatching',
        Sequential = <any> 'Sequential',
        None = <any> 'None'
    }
}

/**
 *
 * @export
 * @interface MassiveSDKModelOffer
 */
export interface MassiveSDKModelOffer {
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelOffer
     */
    deliveryType?: MassiveSDKModelOffer.DeliveryTypeEnum;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelOffer
     */
    resolution?: MassiveSDKModelOffer.ResolutionEnum;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelOffer
     */
    ownership?: MassiveSDKModelOffer.OwnershipEnum;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelOffer
     */
    availability?: MassiveSDKModelOffer.AvailabilityEnum;
    /**
     *
     * @type {Array<string>}
     * @memberof MassiveSDKModelOffer
     */
    scopes?: Array<string>;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelOffer
     */
    maxPlays?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelOffer
     */
    maxDownloads?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelOffer
     */
    rentalPeriod?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelOffer
     */
    playPeriod?: number;
    /**
     *
     * @type {Array<MassiveSDKModelExclusionRule>}
     * @memberof MassiveSDKModelOffer
     */
    exclusionRules?: Array<MassiveSDKModelExclusionRule>;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelOffer
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelOffer
     */
    name?: string;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelOffer
     */
    price?: number;
    /**
     *
     * @type {Date}
     * @memberof MassiveSDKModelOffer
     */
    startDate?: Date;
    /**
     *
     * @type {Date}
     * @memberof MassiveSDKModelOffer
     */
    endDate?: Date;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelOffer
     */
    subscriptionCode?: string;
    /**
     *
     * @type {any}
     * @memberof MassiveSDKModelOffer
     */
    customFields?: any;
}

/**
 * @export
 * @namespace MassiveSDKModelOffer
 */
export namespace MassiveSDKModelOffer {
    /**
     * @export
     * @enum {string}
     */
    export enum DeliveryTypeEnum {
        Stream = <any> 'Stream',
        Download = <any> 'Download',
        StreamOrDownload = <any> 'StreamOrDownload',
        ProgressiveDownload = <any> 'ProgressiveDownload',
        None = <any> 'None'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ResolutionEnum {
        SD = <any> 'SD',
        HD720 = <any> 'HD-720',
        HD1080 = <any> 'HD-1080',
        HD4K = <any> 'HD-4K',
        External = <any> 'External',
        Unknown = <any> 'Unknown'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OwnershipEnum {
        Subscription = <any> 'Subscription',
        Free = <any> 'Free',
        Rent = <any> 'Rent',
        Own = <any> 'Own',
        None = <any> 'None'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum AvailabilityEnum {
        Available = <any> 'Available',
        ComingSoon = <any> 'ComingSoon'
    }
}

/**
 *
 * @export
 * @interface MassiveSDKModelOptions
 */
export interface MassiveSDKModelOptions {
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelOptions
     */
    pageSize?: number;
}

/**
 *
 * @export
 * @interface MassiveSDKModelPagination
 */
export interface MassiveSDKModelPagination {
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelPagination
     */
    next?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelPagination
     */
    previous?: string;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelPagination
     */
    page?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelPagination
     */
    size?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelPagination
     */
    total?: number;
    /**
     *
     * @type {MassiveSDKModelPaginationAuth}
     * @memberof MassiveSDKModelPagination
     */
    authorization?: MassiveSDKModelPaginationAuth;
    /**
     *
     * @type {MassiveSDKModelPaginationOptions}
     * @memberof MassiveSDKModelPagination
     */
    options?: MassiveSDKModelPaginationOptions;
}

/**
 *
 * @export
 * @interface MassiveSDKModelPaginationAuth
 */
export interface MassiveSDKModelPaginationAuth {
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelPaginationAuth
     */
    type?: MassiveSDKModelPaginationAuth.TypeEnum;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelPaginationAuth
     */
    scope?: MassiveSDKModelPaginationAuth.ScopeEnum;
}

/**
 * @export
 * @namespace MassiveSDKModelPaginationAuth
 */
export namespace MassiveSDKModelPaginationAuth {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        UserAccount = <any> 'UserAccount',
        UserProfile = <any> 'UserProfile'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ScopeEnum {
        Catalog = <any> 'Catalog',
        Commerce = <any> 'Commerce',
        Settings = <any> 'Settings'
    }
}

/**
 *
 * @export
 * @interface MassiveSDKModelPaginationOptions
 */
export interface MassiveSDKModelPaginationOptions {
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelPaginationOptions
     */
    order?: MassiveSDKModelPaginationOptions.OrderEnum;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelPaginationOptions
     */
    orderBy?: MassiveSDKModelPaginationOptions.OrderByEnum;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelPaginationOptions
     */
    itemType?: MassiveSDKModelPaginationOptions.ItemTypeEnum;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelPaginationOptions
     */
    pageSize?: number;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelPaginationOptions
     */
    maxRating?: string;
    /**
     *
     * @type {boolean}
     * @memberof MassiveSDKModelPaginationOptions
     */
    completed?: boolean;
}

/**
 * @export
 * @namespace MassiveSDKModelPaginationOptions
 */
export namespace MassiveSDKModelPaginationOptions {
    /**
     * @export
     * @enum {string}
     */
    export enum OrderEnum {
        Asc = <any> 'asc',
        Desc = <any> 'desc'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum OrderByEnum {
        AZ = <any> 'a-z',
        ReleaseYear = <any> 'release-year',
        DateAdded = <any> 'date-added'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ItemTypeEnum {
        Movie = <any> 'movie',
        Show = <any> 'show',
        Season = <any> 'season',
        Episode = <any> 'episode',
        Program = <any> 'program',
        Link = <any> 'link',
        Trailer = <any> 'trailer',
        Channel = <any> 'channel',
        CustomAsset = <any> 'customAsset'
    }
}

/**
 *
 * @export
 * @interface MassiveSDKModelPaging
 */
export interface MassiveSDKModelPaging {
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelPaging
     */
    total?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelPaging
     */
    page?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelPaging
     */
    size?: number;
    /**
     *
     * @type {MassiveSDKModelOptions}
     * @memberof MassiveSDKModelPaging
     */
    options?: MassiveSDKModelOptions;
}

/**
 *
 * @export
 * @interface MassiveSDKModelSeasons
 */
export interface MassiveSDKModelSeasons {
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelSeasons
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelSeasons
     */
    path?: string;
    /**
     *
     * @type {Array<MassiveSDKModelSeasonsItem>}
     * @memberof MassiveSDKModelSeasons
     */
    items?: Array<MassiveSDKModelSeasonsItem>;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelSeasons
     */
    size?: number;
    /**
     *
     * @type {MassiveSDKModelPaging}
     * @memberof MassiveSDKModelSeasons
     */
    paging?: MassiveSDKModelPaging;
}

/**
 *
 * @export
 * @interface MassiveSDKModelSeasonsItem
 */
export interface MassiveSDKModelSeasonsItem {
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof MassiveSDKModelSeasonsItem
     */
    images?: { [key: string]: string; };
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelSeasonsItem
     */
    releaseYear?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelSeasonsItem
     */
    availableEpisodeCount?: number;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelSeasonsItem
     */
    seasonNumber?: number;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelSeasonsItem
     */
    showId?: string;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelSeasonsItem
     */
    episodeCount?: number;
    /**
     *
     * @type {Array<MassiveSDKModelOffer>}
     * @memberof MassiveSDKModelSeasonsItem
     */
    offers?: Array<MassiveSDKModelOffer>;
    /**
     *
     * @type {Array<string>}
     * @memberof MassiveSDKModelSeasonsItem
     */
    scopes?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof MassiveSDKModelSeasonsItem
     */
    categories?: Array<string>;
    /**
     *
     * @type {any}
     * @memberof MassiveSDKModelSeasonsItem
     */
    customFields?: any;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelSeasonsItem
     */
    customId?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof MassiveSDKModelSeasonsItem
     */
    genres?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelSeasonsItem
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelSeasonsItem
     */
    type?: string;
    /**
     *
     * @type {Date}
     * @memberof MassiveSDKModelSeasonsItem
     */
    maximumOfferEnd?: Date;
    /**
     *
     * @type {Array<any>}
     * @memberof MassiveSDKModelSeasonsItem
     */
    media?: Array<any>;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelSeasonsItem
     */
    shortDescription?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelSeasonsItem
     */
    contextualTitle?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelSeasonsItem
     */
    title?: string;
    /**
     *
     * @type {MassiveSDKModelClassification}
     * @memberof MassiveSDKModelSeasonsItem
     */
    classification?: MassiveSDKModelClassification;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelSeasonsItem
     */
    totalUserRatings?: number;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelSeasonsItem
     */
    path?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelSeasonsItem
     */
    showTitle?: string;
}

/**
 *
 * @export
 * @interface MassiveSDKModelShow
 */
export interface MassiveSDKModelShow {
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof MassiveSDKModelShow
     */
    images?: { [key: string]: string; };
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelShow
     */
    advisoryText?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelShow
     */
    copyright?: string;
    /**
     *
     * @type {Array<MassiveSDKModelCredit>}
     * @memberof MassiveSDKModelShow
     */
    credits?: Array<MassiveSDKModelCredit>;
    /**
     *
     * @type {Array<any>}
     * @memberof MassiveSDKModelShow
     */
    customMetadata?: Array<any>;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelShow
     */
    distributor?: string;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelShow
     */
    availableSeasonCount?: number;
    /**
     *
     * @type {Array<MassiveSDKModelOffer>}
     * @memberof MassiveSDKModelShow
     */
    offers?: Array<MassiveSDKModelOffer>;
    /**
     *
     * @type {Array<any>}
     * @memberof MassiveSDKModelShow
     */
    trailers?: Array<any>;
    /**
     *
     * @type {Array<any>}
     * @memberof MassiveSDKModelShow
     */
    vams?: Array<any>;
    /**
     *
     * @type {Array<string>}
     * @memberof MassiveSDKModelShow
     */
    scopes?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof MassiveSDKModelShow
     */
    categories?: Array<string>;
    /**
     *
     * @type {any}
     * @memberof MassiveSDKModelShow
     */
    customFields?: any;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelShow
     */
    customId?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof MassiveSDKModelShow
     */
    genres?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelShow
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelShow
     */
    type?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelShow
     */
    description?: string;
    /**
     *
     * @type {Date}
     * @memberof MassiveSDKModelShow
     */
    maximumOfferEnd?: Date;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelShow
     */
    shortDescription?: string;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelShow
     */
    contextualTitle?: string;
    /**
     *
     * @type {Array<any>}
     * @memberof MassiveSDKModelShow
     */
    themes?: Array<any>;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelShow
     */
    title?: string;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelShow
     */
    totalUserRatings?: number;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelShow
     */
    path?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof MassiveSDKModelShow
     */
    genrePaths?: Array<string>;
    /**
     *
     * @type {MassiveSDKModelSeasons}
     * @memberof MassiveSDKModelShow
     */
    seasons?: MassiveSDKModelSeasons;
}

/**
 *
 * @export
 * @interface MassiveSDKModelTheme
 */
export interface MassiveSDKModelTheme {
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelTheme
     */
    type?: MassiveSDKModelTheme.TypeEnum;
    /**
     *
     * @type {Array<MassiveSDKModelThemeColor>}
     * @memberof MassiveSDKModelTheme
     */
    colors?: Array<MassiveSDKModelThemeColor>;
}

/**
 * @export
 * @namespace MassiveSDKModelTheme
 */
export namespace MassiveSDKModelTheme {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Background = <any> 'Background',
        Text = <any> 'Text',
        Custom = <any> 'Custom'
    }
}

/**
 *
 * @export
 * @interface MassiveSDKModelThemeColor
 */
export interface MassiveSDKModelThemeColor {
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelThemeColor
     */
    name?: string;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelThemeColor
     */
    opacity?: number;
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelThemeColor
     */
    value?: string;
}

/**
 *
 * @export
 * @interface MassiveSDKModelWatched
 */
export interface MassiveSDKModelWatched {
    /**
     *
     * @type {string}
     * @memberof MassiveSDKModelWatched
     */
    itemId?: string;
    /**
     *
     * @type {number}
     * @memberof MassiveSDKModelWatched
     */
    position?: number;
    /**
     *
     * @type {Date}
     * @memberof MassiveSDKModelWatched
     */
    firstWatchedDate?: Date;
    /**
     *
     * @type {Date}
     * @memberof MassiveSDKModelWatched
     */
    lastWatchedDate?: Date;
    /**
     *
     * @type {boolean}
     * @memberof MassiveSDKModelWatched
     */
    isFullyWatched?: boolean;
}


/**
 * AuthorizationApi - fetch parameter creator
 * @export
 */
export const AuthorizationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {BritboxAPIAccountModelsAuthorizationAuthenticateCustomerRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateCustomer(request?: BritboxAPIAccountModelsAuthorizationAuthenticateCustomerRequest, options: any = {}): FetchArgs {
            const localVarPath = `/v1/account/Authorization/authenticateCustomer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BritboxAPIAccountModelsAuthorizationAuthenticateCustomerRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuthAccessToken(request?: BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenRequest, options: any = {}): FetchArgs {
            const localVarPath = `/v1/account/Authorization/getOAuthAccessToken`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {BritboxAPIAccountModelsAuthorizationRefreshTokenRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(request?: BritboxAPIAccountModelsAuthorizationRefreshTokenRequest, options: any = {}): FetchArgs {
            const localVarPath = `/v1/account/Authorization/refreshToken`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BritboxAPIAccountModelsAuthorizationRefreshTokenRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorizationApi - functional programming interface
 * @export
 */
export const AuthorizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {BritboxAPIAccountModelsAuthorizationAuthenticateCustomerRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateCustomer(request?: BritboxAPIAccountModelsAuthorizationAuthenticateCustomerRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsAuthorizationRefreshTokenResponse> {
            const localVarFetchArgs = AuthorizationApiFetchParamCreator(configuration).authenticateCustomer(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuthAccessToken(request?: BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenResponse> {
            const localVarFetchArgs = AuthorizationApiFetchParamCreator(configuration).getOAuthAccessToken(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {BritboxAPIAccountModelsAuthorizationRefreshTokenRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(request?: BritboxAPIAccountModelsAuthorizationRefreshTokenRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsAuthorizationRefreshTokenResponse> {
            const localVarFetchArgs = AuthorizationApiFetchParamCreator(configuration).refreshToken(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthorizationApi - factory interface
 * @export
 */
export const AuthorizationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {BritboxAPIAccountModelsAuthorizationAuthenticateCustomerRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateCustomer(request?: BritboxAPIAccountModelsAuthorizationAuthenticateCustomerRequest, options?: any) {
            return AuthorizationApiFp(configuration).authenticateCustomer(request, options)(fetch, basePath);
        },
        /**
         *
         * @param {BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuthAccessToken(request?: BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenRequest, options?: any) {
            return AuthorizationApiFp(configuration).getOAuthAccessToken(request, options)(fetch, basePath);
        },
        /**
         *
         * @param {BritboxAPIAccountModelsAuthorizationRefreshTokenRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(request?: BritboxAPIAccountModelsAuthorizationRefreshTokenRequest, options?: any) {
            return AuthorizationApiFp(configuration).refreshToken(request, options)(fetch, basePath);
        },
    };
};

/**
 * AuthorizationApi - object-oriented interface
 * @export
 * @class AuthorizationApi
 * @extends {BaseAPI}
 */
export class AuthorizationApi extends BaseAPI {
    /**
     *
     * @param {BritboxAPIAccountModelsAuthorizationAuthenticateCustomerRequest} [request]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public authenticateCustomer(request?: BritboxAPIAccountModelsAuthorizationAuthenticateCustomerRequest, options?: any) {
        return AuthorizationApiFp(this.configuration).authenticateCustomer(request, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenRequest} [request]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public getOAuthAccessToken(request?: BritboxAPIAccountModelsAuthorizationGetOAuthAccessTokenRequest, options?: any) {
        return AuthorizationApiFp(this.configuration).getOAuthAccessToken(request, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {BritboxAPIAccountModelsAuthorizationRefreshTokenRequest} [request]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public refreshToken(request?: BritboxAPIAccountModelsAuthorizationRefreshTokenRequest, options?: any) {
        return AuthorizationApiFp(this.configuration).refreshToken(request, options)(this.fetch, this.basePath);
    }

}

/**
 * CustomerApi - fetch parameter creator
 * @export
 */
export const CustomerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {BritboxDataEvergentModelsAddSubscriptionRequestMessage} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubscription(request?: BritboxDataEvergentModelsAddSubscriptionRequestMessage, options: any = {}): FetchArgs {
            const localVarPath = `/v1/account/Customer/subscription`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BritboxDataEvergentModelsAddSubscriptionRequestMessage" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [dmaID]
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(dmaID?: string, countryCode?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/account/Customer/products`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (dmaID !== undefined) {
                localVarQueryParameter['dmaID'] = dmaID;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerApi - functional programming interface
 * @export
 */
export const CustomerApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {BritboxDataEvergentModelsAddSubscriptionRequestMessage} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubscription(request?: BritboxDataEvergentModelsAddSubscriptionRequestMessage, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsCustomerAddSubscriptionResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).addSubscription(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} [dmaID]
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(dmaID?: string, countryCode?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsCustomerGetProductsResponse> {
            const localVarFetchArgs = CustomerApiFetchParamCreator(configuration).getProducts(dmaID, countryCode, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomerApi - factory interface
 * @export
 */
export const CustomerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {BritboxDataEvergentModelsAddSubscriptionRequestMessage} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubscription(request?: BritboxDataEvergentModelsAddSubscriptionRequestMessage, options?: any) {
            return CustomerApiFp(configuration).addSubscription(request, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} [dmaID]
         * @param {string} [countryCode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(dmaID?: string, countryCode?: string, options?: any) {
            return CustomerApiFp(configuration).getProducts(dmaID, countryCode, options)(fetch, basePath);
        },
    };
};

/**
 * CustomerApi - object-oriented interface
 * @export
 * @class CustomerApi
 * @extends {BaseAPI}
 */
export class CustomerApi extends BaseAPI {
    /**
     *
     * @param {BritboxDataEvergentModelsAddSubscriptionRequestMessage} [request]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public addSubscription(request?: BritboxDataEvergentModelsAddSubscriptionRequestMessage, options?: any) {
        return CustomerApiFp(this.configuration).addSubscription(request, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {string} [dmaID]
     * @param {string} [countryCode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerApi
     */
    public getProducts(dmaID?: string, countryCode?: string, options?: any) {
        return CustomerApiFp(this.configuration).getProducts(dmaID, countryCode, options)(this.fetch, this.basePath);
    }

}

/**
 * DeviceApi - fetch parameter creator
 * @export
 */
export const DeviceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {BritboxAPIAccountModelsDeviceGenerateDeviceActivationCodeRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateDeviceActivationCode(request?: BritboxAPIAccountModelsDeviceGenerateDeviceActivationCodeRequest, options: any = {}): FetchArgs {
            const localVarPath = `/v1/account/Device/generateDeviceActivationCode`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BritboxAPIAccountModelsDeviceGenerateDeviceActivationCodeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {BritboxAPIAccountModelsDeviceRegisterDeviceRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerDevice(request?: BritboxAPIAccountModelsDeviceRegisterDeviceRequest, options: any = {}): FetchArgs {
            const localVarPath = `/v1/account/Device/registerDevice`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BritboxAPIAccountModelsDeviceRegisterDeviceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceApi - functional programming interface
 * @export
 */
export const DeviceApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {BritboxAPIAccountModelsDeviceGenerateDeviceActivationCodeRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateDeviceActivationCode(request?: BritboxAPIAccountModelsDeviceGenerateDeviceActivationCodeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsDeviceGenerateDeviceActivationCodeResponse> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).generateDeviceActivationCode(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {BritboxAPIAccountModelsDeviceRegisterDeviceRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerDevice(request?: BritboxAPIAccountModelsDeviceRegisterDeviceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsDeviceRegisterDeviceResponse> {
            const localVarFetchArgs = DeviceApiFetchParamCreator(configuration).registerDevice(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DeviceApi - factory interface
 * @export
 */
export const DeviceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {BritboxAPIAccountModelsDeviceGenerateDeviceActivationCodeRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateDeviceActivationCode(request?: BritboxAPIAccountModelsDeviceGenerateDeviceActivationCodeRequest, options?: any) {
            return DeviceApiFp(configuration).generateDeviceActivationCode(request, options)(fetch, basePath);
        },
        /**
         *
         * @param {BritboxAPIAccountModelsDeviceRegisterDeviceRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerDevice(request?: BritboxAPIAccountModelsDeviceRegisterDeviceRequest, options?: any) {
            return DeviceApiFp(configuration).registerDevice(request, options)(fetch, basePath);
        },
    };
};

/**
 * DeviceApi - object-oriented interface
 * @export
 * @class DeviceApi
 * @extends {BaseAPI}
 */
export class DeviceApi extends BaseAPI {
    /**
     *
     * @param {BritboxAPIAccountModelsDeviceGenerateDeviceActivationCodeRequest} [request]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public generateDeviceActivationCode(request?: BritboxAPIAccountModelsDeviceGenerateDeviceActivationCodeRequest, options?: any) {
        return DeviceApiFp(this.configuration).generateDeviceActivationCode(request, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {BritboxAPIAccountModelsDeviceRegisterDeviceRequest} [request]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public registerDevice(request?: BritboxAPIAccountModelsDeviceRegisterDeviceRequest, options?: any) {
        return DeviceApiFp(this.configuration).registerDevice(request, options)(this.fetch, this.basePath);
    }

}

/**
 * MediaFileApi - fetch parameter creator
 * @export
 */
export const MediaFileApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} id
         * @param {string} [device]
         * @param {string} [sub]
         * @param {Array<string>} [segments]
         * @param {boolean} [useCustomId]
         * @param {string} [pcToken]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemMediaFiles(id: string, device?: string, sub?: string, segments?: Array<string>, useCustomId?: boolean, pcToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getItemMediaFiles.');
            }
            const localVarPath = `/v1/account/MediaFile/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (sub !== undefined) {
                localVarQueryParameter['sub'] = sub;
            }

            if (segments) {
                localVarQueryParameter['segments'] = segments;
            }

            if (useCustomId !== undefined) {
                localVarQueryParameter['useCustomId'] = useCustomId;
            }

            if (pcToken !== undefined) {
                localVarQueryParameter['pcToken'] = pcToken;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaFileApi - functional programming interface
 * @export
 */
export const MediaFileApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} id
         * @param {string} [device]
         * @param {string} [sub]
         * @param {Array<string>} [segments]
         * @param {boolean} [useCustomId]
         * @param {string} [pcToken]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemMediaFiles(id: string, device?: string, sub?: string, segments?: Array<string>, useCustomId?: boolean, pcToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsMediaFileGetItemMediaFilesResponse> {
            const localVarFetchArgs = MediaFileApiFetchParamCreator(configuration).getItemMediaFiles(id, device, sub, segments, useCustomId, pcToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MediaFileApi - factory interface
 * @export
 */
export const MediaFileApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {string} id
         * @param {string} [device]
         * @param {string} [sub]
         * @param {Array<string>} [segments]
         * @param {boolean} [useCustomId]
         * @param {string} [pcToken]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemMediaFiles(id: string, device?: string, sub?: string, segments?: Array<string>, useCustomId?: boolean, pcToken?: string, options?: any) {
            return MediaFileApiFp(configuration).getItemMediaFiles(id, device, sub, segments, useCustomId, pcToken, options)(fetch, basePath);
        },
    };
};

/**
 * MediaFileApi - object-oriented interface
 * @export
 * @class MediaFileApi
 * @extends {BaseAPI}
 */
export class MediaFileApi extends BaseAPI {
    /**
     *
     * @param {string} id
     * @param {string} [device]
     * @param {string} [sub]
     * @param {Array<string>} [segments]
     * @param {boolean} [useCustomId]
     * @param {string} [pcToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaFileApi
     */
    public getItemMediaFiles(id: string, device?: string, sub?: string, segments?: Array<string>, useCustomId?: boolean, pcToken?: string, options?: any) {
        return MediaFileApiFp(this.configuration).getItemMediaFiles(id, device, sub, segments, useCustomId, pcToken, options)(this.fetch, this.basePath);
    }

}

/**
 * ProfileApi - fetch parameter creator
 * @export
 */
export const ProfileApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkItem(itemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling bookmarkItem.');
            }
            const localVarPath = `/v1/account/Profile/bookmarks/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [classificationName]
         * @param {string} [segment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkParentalControl(classificationName?: string, segment?: string, options: any = {}): FetchArgs {
            const localVarPath = `/v1/account/Profile/parentalcontrol/canstream`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (classificationName !== undefined) {
                localVarQueryParameter['classificationName'] = classificationName;
            }

            if (segment !== undefined) {
                localVarQueryParameter['segment'] = segment;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemBookmark(itemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteItemBookmark.');
            }
            const localVarPath = `/v1/account/Profile/bookmarks/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {BritboxAPIAccountModelsProfileDeleteWatchedRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatched(request?: BritboxAPIAccountModelsProfileDeleteWatchedRequest, options: any = {}): FetchArgs {
            const localVarPath = `/v1/account/Profile/watched`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BritboxAPIAccountModelsProfileDeleteWatchedRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {string} [order]
         * @param {string} [itemType]
         * @param {string} [device]
         * @param {string} [sub]
         * @param {boolean} [useCustomId]
         * @param {Array<string>} [segments]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarkList(page?: number, pageSize?: number, order?: string, itemType?: string, device?: string, sub?: string, useCustomId?: boolean, segments?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/v1/account/Profile/bookmarks/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (itemType !== undefined) {
                localVarQueryParameter['itemType'] = itemType;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (sub !== undefined) {
                localVarQueryParameter['sub'] = sub;
            }

            if (useCustomId !== undefined) {
                localVarQueryParameter['useCustomId'] = useCustomId;
            }

            if (segments) {
                localVarQueryParameter['segments'] = segments;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarks(options: any = {}): FetchArgs {
            const localVarPath = `/v1/account/Profile/bookmarks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContinueWatchingList(itemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getContinueWatchingList.');
            }
            const localVarPath = `/v1/account/Profile/watched/show/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [showItemType]
         * @param {Array<string>} [include]
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {string} [maxRating]
         * @param {string} [device]
         * @param {string} [sub]
         * @param {Array<string>} [segments]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContinueWatchingList_1(showItemType?: string, include?: Array<string>, page?: number, pageSize?: number, maxRating?: string, device?: string, sub?: string, segments?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/v1/account/Profile/continue-watching/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (showItemType !== undefined) {
                localVarQueryParameter['showItemType'] = showItemType;
            }

            if (include) {
                localVarQueryParameter['include'] = include;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (maxRating !== undefined) {
                localVarQueryParameter['maxRating'] = maxRating;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (sub !== undefined) {
                localVarQueryParameter['sub'] = sub;
            }

            if (segments) {
                localVarQueryParameter['segments'] = segments;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemBookmark(itemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getItemBookmark.');
            }
            const localVarPath = `/v1/account/Profile/bookmarks/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemWatchedStatus(itemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getItemWatchedStatus.');
            }
            const localVarPath = `/v1/account/Profile/watched/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} itemId
         * @param {string} [maxRating]
         * @param {string} [expand]
         * @param {string} [device]
         * @param {string} [sub]
         * @param {Array<string>} [segments]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextPlaybackItem(itemId: string, maxRating?: string, expand?: string, device?: string, sub?: string, segments?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getNextPlaybackItem.');
            }
            const localVarPath = `/v1/account/Profile/items/{itemId}/next`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (maxRating !== undefined) {
                localVarQueryParameter['maxRating'] = maxRating;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (sub !== undefined) {
                localVarQueryParameter['sub'] = sub;
            }

            if (segments) {
                localVarQueryParameter['segments'] = segments;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentalControlDetails(options: any = {}): FetchArgs {
            const localVarPath = `/v1/account/Profile/parentalcontrol`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {boolean} [useCustomId]
         * @param {Array<string>} [segments]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(useCustomId?: boolean, segments?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/v1/account/Profile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (useCustomId !== undefined) {
                localVarQueryParameter['useCustomId'] = useCustomId;
            }

            if (segments) {
                localVarQueryParameter['segments'] = segments;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatched(options: any = {}): FetchArgs {
            const localVarPath = `/v1/account/Profile/watched`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {boolean} [completed]
         * @param {string} [order]
         * @param {string} [orderBy]
         * @param {string} [itemType]
         * @param {string} [device]
         * @param {string} [sub]
         * @param {boolean} [useCustomId]
         * @param {Array<string>} [segments]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchedList(page?: number, pageSize?: number, completed?: boolean, order?: string, orderBy?: string, itemType?: string, device?: string, sub?: string, useCustomId?: boolean, segments?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/v1/account/Profile/watched/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (completed !== undefined) {
                localVarQueryParameter['completed'] = completed;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (itemType !== undefined) {
                localVarQueryParameter['itemType'] = itemType;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (sub !== undefined) {
                localVarQueryParameter['sub'] = sub;
            }

            if (useCustomId !== undefined) {
                localVarQueryParameter['useCustomId'] = useCustomId;
            }

            if (segments) {
                localVarQueryParameter['segments'] = segments;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} itemId
         * @param {BritboxAPIAccountModelsProfileSetItemWatchedStatusRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItemWatchedStatus(itemId: string, request?: BritboxAPIAccountModelsProfileSetItemWatchedStatusRequest, options: any = {}): FetchArgs {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling setItemWatchedStatus.');
            }
            const localVarPath = `/v1/account/Profile/watched/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BritboxAPIAccountModelsProfileSetItemWatchedStatusRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {BritboxAPIAccountModelsProfileUpdateParentalControlDetailsRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParentalControlDetails(request?: BritboxAPIAccountModelsProfileUpdateParentalControlDetailsRequest, options: any = {}): FetchArgs {
            const localVarPath = `/v1/account/Profile/parentalcontrol`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BritboxAPIAccountModelsProfileUpdateParentalControlDetailsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {BritboxAPIAccountModelsProfileValidateParentalControlPINRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateParentalControlPIN(request?: BritboxAPIAccountModelsProfileValidateParentalControlPINRequest, options: any = {}): FetchArgs {
            const localVarPath = `/v1/account/Profile/parentalcontrol/validate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AWSApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication JWToken required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BritboxAPIAccountModelsProfileValidateParentalControlPINRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfileApi - functional programming interface
 * @export
 */
export const ProfileApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkItem(itemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsProfileBookmarkItemResponse> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).bookmarkItem(itemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} [classificationName]
         * @param {string} [segment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkParentalControl(classificationName?: string, segment?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsProfileCheckParentalControlResponse> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).checkParentalControl(classificationName, segment, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemBookmark(itemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).deleteItemBookmark(itemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {BritboxAPIAccountModelsProfileDeleteWatchedRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatched(request?: BritboxAPIAccountModelsProfileDeleteWatchedRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).deleteWatched(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {string} [order]
         * @param {string} [itemType]
         * @param {string} [device]
         * @param {string} [sub]
         * @param {boolean} [useCustomId]
         * @param {Array<string>} [segments]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarkList(page?: number, pageSize?: number, order?: string, itemType?: string, device?: string, sub?: string, useCustomId?: boolean, segments?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsProfileGetBookmarkListResponse> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).getBookmarkList(page, pageSize, order, itemType, device, sub, useCustomId, segments, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarks(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsProfileGetBookmarksResponse> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).getBookmarks(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContinueWatchingList(itemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsProfileGetItemWatchedStatusResponse> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).getContinueWatchingList(itemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} [showItemType]
         * @param {Array<string>} [include]
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {string} [maxRating]
         * @param {string} [device]
         * @param {string} [sub]
         * @param {Array<string>} [segments]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContinueWatchingList_1(showItemType?: string, include?: Array<string>, page?: number, pageSize?: number, maxRating?: string, device?: string, sub?: string, segments?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsProfileGetContinueWatchingListResponse> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).getContinueWatchingList_1(showItemType, include, page, pageSize, maxRating, device, sub, segments, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemBookmark(itemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsProfileGetItemBookmarkResponse> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).getItemBookmark(itemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemWatchedStatus(itemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsProfileGetItemWatchedStatusResponse> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).getItemWatchedStatus(itemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} itemId
         * @param {string} [maxRating]
         * @param {string} [expand]
         * @param {string} [device]
         * @param {string} [sub]
         * @param {Array<string>} [segments]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextPlaybackItem(itemId: string, maxRating?: string, expand?: string, device?: string, sub?: string, segments?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsProfileGetNextPlaybackItemResponse> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).getNextPlaybackItem(itemId, maxRating, expand, device, sub, segments, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentalControlDetails(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsProfileGetParentalControlDetailsResponse> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).getParentalControlDetails(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {boolean} [useCustomId]
         * @param {Array<string>} [segments]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(useCustomId?: boolean, segments?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsProfileGetProfileResponse> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).getProfile(useCustomId, segments, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatched(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsProfileGetWatchedResponse> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).getWatched(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {boolean} [completed]
         * @param {string} [order]
         * @param {string} [orderBy]
         * @param {string} [itemType]
         * @param {string} [device]
         * @param {string} [sub]
         * @param {boolean} [useCustomId]
         * @param {Array<string>} [segments]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchedList(page?: number, pageSize?: number, completed?: boolean, order?: string, orderBy?: string, itemType?: string, device?: string, sub?: string, useCustomId?: boolean, segments?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsProfileGetWatchedListResponse> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).getWatchedList(page, pageSize, completed, order, orderBy, itemType, device, sub, useCustomId, segments, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {string} itemId
         * @param {BritboxAPIAccountModelsProfileSetItemWatchedStatusRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItemWatchedStatus(itemId: string, request?: BritboxAPIAccountModelsProfileSetItemWatchedStatusRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsProfileSetItemWatchedStatusResponse> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).setItemWatchedStatus(itemId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {BritboxAPIAccountModelsProfileUpdateParentalControlDetailsRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParentalControlDetails(request?: BritboxAPIAccountModelsProfileUpdateParentalControlDetailsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsProfileUpdateParentalControlDetailsResponse> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).updateParentalControlDetails(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @param {BritboxAPIAccountModelsProfileValidateParentalControlPINRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateParentalControlPIN(request?: BritboxAPIAccountModelsProfileValidateParentalControlPINRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BritboxAPIAccountModelsProfileValidateParentalControlPINResponse> {
            const localVarFetchArgs = ProfileApiFetchParamCreator(configuration).validateParentalControlPIN(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProfileApi - factory interface
 * @export
 */
export const ProfileApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookmarkItem(itemId: string, options?: any) {
            return ProfileApiFp(configuration).bookmarkItem(itemId, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} [classificationName]
         * @param {string} [segment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkParentalControl(classificationName?: string, segment?: string, options?: any) {
            return ProfileApiFp(configuration).checkParentalControl(classificationName, segment, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemBookmark(itemId: string, options?: any) {
            return ProfileApiFp(configuration).deleteItemBookmark(itemId, options)(fetch, basePath);
        },
        /**
         *
         * @param {BritboxAPIAccountModelsProfileDeleteWatchedRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatched(request?: BritboxAPIAccountModelsProfileDeleteWatchedRequest, options?: any) {
            return ProfileApiFp(configuration).deleteWatched(request, options)(fetch, basePath);
        },
        /**
         *
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {string} [order]
         * @param {string} [itemType]
         * @param {string} [device]
         * @param {string} [sub]
         * @param {boolean} [useCustomId]
         * @param {Array<string>} [segments]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarkList(page?: number, pageSize?: number, order?: string, itemType?: string, device?: string, sub?: string, useCustomId?: boolean, segments?: Array<string>, options?: any) {
            return ProfileApiFp(configuration).getBookmarkList(page, pageSize, order, itemType, device, sub, useCustomId, segments, options)(fetch, basePath);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmarks(options?: any) {
            return ProfileApiFp(configuration).getBookmarks(options)(fetch, basePath);
        },
        /**
         *
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContinueWatchingList(itemId: string, options?: any) {
            return ProfileApiFp(configuration).getContinueWatchingList(itemId, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} [showItemType]
         * @param {Array<string>} [include]
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {string} [maxRating]
         * @param {string} [device]
         * @param {string} [sub]
         * @param {Array<string>} [segments]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContinueWatchingList_1(showItemType?: string, include?: Array<string>, page?: number, pageSize?: number, maxRating?: string, device?: string, sub?: string, segments?: Array<string>, options?: any) {
            return ProfileApiFp(configuration).getContinueWatchingList_1(showItemType, include, page, pageSize, maxRating, device, sub, segments, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemBookmark(itemId: string, options?: any) {
            return ProfileApiFp(configuration).getItemBookmark(itemId, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemWatchedStatus(itemId: string, options?: any) {
            return ProfileApiFp(configuration).getItemWatchedStatus(itemId, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} itemId
         * @param {string} [maxRating]
         * @param {string} [expand]
         * @param {string} [device]
         * @param {string} [sub]
         * @param {Array<string>} [segments]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextPlaybackItem(itemId: string, maxRating?: string, expand?: string, device?: string, sub?: string, segments?: Array<string>, options?: any) {
            return ProfileApiFp(configuration).getNextPlaybackItem(itemId, maxRating, expand, device, sub, segments, options)(fetch, basePath);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentalControlDetails(options?: any) {
            return ProfileApiFp(configuration).getParentalControlDetails(options)(fetch, basePath);
        },
        /**
         *
         * @param {boolean} [useCustomId]
         * @param {Array<string>} [segments]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(useCustomId?: boolean, segments?: Array<string>, options?: any) {
            return ProfileApiFp(configuration).getProfile(useCustomId, segments, options)(fetch, basePath);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatched(options?: any) {
            return ProfileApiFp(configuration).getWatched(options)(fetch, basePath);
        },
        /**
         *
         * @param {number} [page]
         * @param {number} [pageSize]
         * @param {boolean} [completed]
         * @param {string} [order]
         * @param {string} [orderBy]
         * @param {string} [itemType]
         * @param {string} [device]
         * @param {string} [sub]
         * @param {boolean} [useCustomId]
         * @param {Array<string>} [segments]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchedList(page?: number, pageSize?: number, completed?: boolean, order?: string, orderBy?: string, itemType?: string, device?: string, sub?: string, useCustomId?: boolean, segments?: Array<string>, options?: any) {
            return ProfileApiFp(configuration).getWatchedList(page, pageSize, completed, order, orderBy, itemType, device, sub, useCustomId, segments, options)(fetch, basePath);
        },
        /**
         *
         * @param {string} itemId
         * @param {BritboxAPIAccountModelsProfileSetItemWatchedStatusRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItemWatchedStatus(itemId: string, request?: BritboxAPIAccountModelsProfileSetItemWatchedStatusRequest, options?: any) {
            return ProfileApiFp(configuration).setItemWatchedStatus(itemId, request, options)(fetch, basePath);
        },
        /**
         *
         * @param {BritboxAPIAccountModelsProfileUpdateParentalControlDetailsRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParentalControlDetails(request?: BritboxAPIAccountModelsProfileUpdateParentalControlDetailsRequest, options?: any) {
            return ProfileApiFp(configuration).updateParentalControlDetails(request, options)(fetch, basePath);
        },
        /**
         *
         * @param {BritboxAPIAccountModelsProfileValidateParentalControlPINRequest} [request]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateParentalControlPIN(request?: BritboxAPIAccountModelsProfileValidateParentalControlPINRequest, options?: any) {
            return ProfileApiFp(configuration).validateParentalControlPIN(request, options)(fetch, basePath);
        },
    };
};

/**
 * ProfileApi - object-oriented interface
 * @export
 * @class ProfileApi
 * @extends {BaseAPI}
 */
export class ProfileApi extends BaseAPI {
    /**
     *
     * @param {string} itemId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public bookmarkItem(itemId: string, options?: any) {
        return ProfileApiFp(this.configuration).bookmarkItem(itemId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {string} [classificationName]
     * @param {string} [segment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public checkParentalControl(classificationName?: string, segment?: string, options?: any) {
        return ProfileApiFp(this.configuration).checkParentalControl(classificationName, segment, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {string} itemId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public deleteItemBookmark(itemId: string, options?: any) {
        return ProfileApiFp(this.configuration).deleteItemBookmark(itemId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {BritboxAPIAccountModelsProfileDeleteWatchedRequest} [request]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public deleteWatched(request?: BritboxAPIAccountModelsProfileDeleteWatchedRequest, options?: any) {
        return ProfileApiFp(this.configuration).deleteWatched(request, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {string} [order]
     * @param {string} [itemType]
     * @param {string} [device]
     * @param {string} [sub]
     * @param {boolean} [useCustomId]
     * @param {Array<string>} [segments]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getBookmarkList(page?: number, pageSize?: number, order?: string, itemType?: string, device?: string, sub?: string, useCustomId?: boolean, segments?: Array<string>, options?: any) {
        return ProfileApiFp(this.configuration).getBookmarkList(page, pageSize, order, itemType, device, sub, useCustomId, segments, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getBookmarks(options?: any) {
        return ProfileApiFp(this.configuration).getBookmarks(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {string} itemId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getContinueWatchingList(itemId: string, options?: any) {
        return ProfileApiFp(this.configuration).getContinueWatchingList(itemId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {string} [showItemType]
     * @param {Array<string>} [include]
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {string} [maxRating]
     * @param {string} [device]
     * @param {string} [sub]
     * @param {Array<string>} [segments]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getContinueWatchingList_1(showItemType?: string, include?: Array<string>, page?: number, pageSize?: number, maxRating?: string, device?: string, sub?: string, segments?: Array<string>, options?: any) {
        return ProfileApiFp(this.configuration).getContinueWatchingList_1(showItemType, include, page, pageSize, maxRating, device, sub, segments, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {string} itemId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getItemBookmark(itemId: string, options?: any) {
        return ProfileApiFp(this.configuration).getItemBookmark(itemId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {string} itemId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getItemWatchedStatus(itemId: string, options?: any) {
        return ProfileApiFp(this.configuration).getItemWatchedStatus(itemId, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {string} itemId
     * @param {string} [maxRating]
     * @param {string} [expand]
     * @param {string} [device]
     * @param {string} [sub]
     * @param {Array<string>} [segments]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getNextPlaybackItem(itemId: string, maxRating?: string, expand?: string, device?: string, sub?: string, segments?: Array<string>, options?: any) {
        return ProfileApiFp(this.configuration).getNextPlaybackItem(itemId, maxRating, expand, device, sub, segments, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getParentalControlDetails(options?: any) {
        return ProfileApiFp(this.configuration).getParentalControlDetails(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {boolean} [useCustomId]
     * @param {Array<string>} [segments]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getProfile(useCustomId?: boolean, segments?: Array<string>, options?: any) {
        return ProfileApiFp(this.configuration).getProfile(useCustomId, segments, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getWatched(options?: any) {
        return ProfileApiFp(this.configuration).getWatched(options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {number} [page]
     * @param {number} [pageSize]
     * @param {boolean} [completed]
     * @param {string} [order]
     * @param {string} [orderBy]
     * @param {string} [itemType]
     * @param {string} [device]
     * @param {string} [sub]
     * @param {boolean} [useCustomId]
     * @param {Array<string>} [segments]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public getWatchedList(page?: number, pageSize?: number, completed?: boolean, order?: string, orderBy?: string, itemType?: string, device?: string, sub?: string, useCustomId?: boolean, segments?: Array<string>, options?: any) {
        return ProfileApiFp(this.configuration).getWatchedList(page, pageSize, completed, order, orderBy, itemType, device, sub, useCustomId, segments, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {string} itemId
     * @param {BritboxAPIAccountModelsProfileSetItemWatchedStatusRequest} [request]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public setItemWatchedStatus(itemId: string, request?: BritboxAPIAccountModelsProfileSetItemWatchedStatusRequest, options?: any) {
        return ProfileApiFp(this.configuration).setItemWatchedStatus(itemId, request, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {BritboxAPIAccountModelsProfileUpdateParentalControlDetailsRequest} [request]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public updateParentalControlDetails(request?: BritboxAPIAccountModelsProfileUpdateParentalControlDetailsRequest, options?: any) {
        return ProfileApiFp(this.configuration).updateParentalControlDetails(request, options)(this.fetch, this.basePath);
    }

    /**
     *
     * @param {BritboxAPIAccountModelsProfileValidateParentalControlPINRequest} [request]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfileApi
     */
    public validateParentalControlPIN(request?: BritboxAPIAccountModelsProfileValidateParentalControlPINRequest, options?: any) {
        return ProfileApiFp(this.configuration).validateParentalControlPIN(request, options)(this.fetch, this.basePath);
    }

}

